############################################################################
##This is used to find the High density box centre in water distribution.
##We used the water coordidates in the first step generated by 'readDCDFile'
##We used grid method to find the High water occupied boxes and uses optimize
##method to find the high density water place with an r<=1.5 anstrom.
##
##Xianqiang Sun
##TheoChem&Bio
##KTH
##2012-05-14
###########################################################################

import numpy
import sys
sys.path.append('/home/zy/anaconda2/lib/python2.7/site-packages/')
#sys.path.append('/home/x/xiansu/pfs/program/numpy/lib/python2.6/site-packages')
#from Numeric import *
from datetime import datetime

waters=open('distance.txt','r')
##the file were read through the output file of 'read DCD file'
waterCentre=open('waterCentre.txt','w')
##waterCentre2=open('waterCentre2.txt','w')

def formatWaterInfor(self):
    waterInfor=[]
    for line in self:
        line=line.split()
        if line[0]=='SOL':
            line[1]=line[1][:-1]
            line[-1]=line[-1][1:-2]
        elif line[0]=='frame':
            frameNo=line[1]
        if line[0]=='SOL':
            line.append(str(frameNo))
            waterInfor.append(line)
    return waterInfor

##formatWaterInfor is used to read the waters information from the input
##file and translate it into list format. The frame No. information were
##also added to the list. the format is [[waterInfor]....]

def getWaterCoord(self,firstFrame,frequency):
    waterCoord=[]
    for waterAtom in self:
        frameNo=waterAtom[-1]
##        print frameNo
        if int(frameNo)>=firstFrame:
            if (int(frameNo)/frequency)-(int(frameNo)/float(frequency))==0:
                atomCoord=waterAtom[3:-2]
                atomCoordFloat=[]
                for coord in atomCoord:
                    coord=float(coord)
                    atomCoordFloat.append(coord)
                waterCoord.append(atomCoordFloat)
    return waterCoord
##getWaterCoord use the output of 'formatWaterInfor' as the input. It will
##read the atom Coordiates and extract them ad the float point numbers. Moreover,
##the firstFrame number and frequency can be seted to save computational time. Each
##coordidates can be save as one element in one list, the format is:[[x1,y1,z2]
##,[x2,y2,z2]...]

def getMinAndMax(self):
    minAndMax=[]
    xmin=self[0][0]
    ymin=self[0][1]
    zmin=self[0][2]
    xmax=self[0][0]
    ymax=self[0][1]
    zmax=self[0][2]
    for coord in self:
        if coord[0]>=xmax:
            xmax=coord[0]
        if coord[0]<=xmin:
            xmin=coord[0]
        if coord[1]>=ymax:
            ymax=coord[1]
        if coord[1]<=ymin:
            ymin=coord[1]
        if coord[2]>=zmax:
            zmax=coord[2]
        if coord[2]<=zmin:
            zmin=coord[2]
    minAndMax.append(xmin)
    minAndMax.append(ymin)
    minAndMax.append(zmin)
    minAndMax.append(xmax)
    minAndMax.append(ymax)
    minAndMax.append(zmax)
    return minAndMax
##getMaxAndMin read a set of coordidates with the format of [[x1,y1,z2]
##,[x2,y2,z2]...](the value should be folat numbers), then get the xmin
##ymin zmin and xmax ymax zmax, the output wer saved as a list with the
##format of[xmin,ymin,zmin,xmax,ymax,zmax]

def divideGrid(self):
    boxSize=[]
    xmin=self[0]

    ymin=self[1]
    zmin=self[2]
    xmax=self[3]
    ymax=self[4]
    zmax=self[5]
    xboxsize=int((xmax-xmin)/1.6)+1
    yboxsize=int((ymax-ymin)/1.6)+1
    zboxsize=int((zmax-zmin)/1.6)+1
    boxSize.append(xboxsize)
    boxSize.append(yboxsize)
    boxSize.append(zboxsize)
    print xboxsize
    return boxSize
##divideGrid read the format of [xmin,ymin,zmin,xmax,ymax,zmax] and devide the
##total box into grid with the wideth of 1.6 anstrom, we set 1.6 as the width
##because the oxygen in water has a distance of 2.8. 1.6*1.7<2.8. Therefore, I
##it. The output is [xboxsize,yboxsize,zboxsize](integar)

def generateGrid(self,boxMin):
    xgridSize=self[0]
    ygridSize=self[1]
    zgridSize=self[2]
    xmin=boxMin[0]
    ymin=boxMin[1]
    zmin=boxMin[2]
    totalGrid=[]
    for x in range(xgridSize):
        minboxx=[]
        minboxx.append(xmin)
        xmin=xmin+1.6
        minboxx.append(xmin)
        for y in range(ygridSize):
            minboxy=[]
            minboxy.append(ymin)
            ymin=ymin+1.6
            minboxy.append(ymin)
            for z in range(zgridSize):
                minboxz=[]
                minbox=[]
                minboxz.append(zmin)
                zmin=zmin+1.6
                minboxz.append(zmin)
                minbox.append(minboxx[0])
                minbox.append(minboxy[0])
                minbox.append(minboxz[0])
                minbox.append(minboxx[1])
                minbox.append(minboxy[1])
                minbox.append(minboxz[1])
                totalGrid.append(minbox)
            zmin=boxMin[2]
        ymin=boxMin[1]
    return totalGrid

##generateGrid is use to generate grid from coordidates space, the input includes:
##1: self [xgridsize,ygridsize,zgridsize],2: boxMin [xmin,ymin,zmin......]
##the out put is the totalGrid for all the coordidates space. the format is:
##[[xmin,ymin,zmin,xmax,ymax,zmax].....[xmin,ymin,zmin,xmax,ymax,zmax]]

def getWaterDistGrid(self,totalGrid):
    waterDistGrid=[]
    for No in range(len(totalGrid)):
        waterDistGrid.append([])
    while(self):
        coord = self.pop()
        print len(self)
        gridNo=0
        for grid in totalGrid:
            if grid[3]>coord[0]>=grid[0] and grid[4]>coord[1]>=grid[1] and grid[5]>coord[2]>=grid[2]:
                waterDistGrid[gridNo].append(coord)
                
                #print coord,'is in ',grid
                #print waterDistGrid[gridNo]
                #print "gridNo:%s" %gridNo
            gridNo=gridNo+1
        #print coord
    return waterDistGrid

##getWaterDistGrid needs two inputs: 1,self: the coordidats saved as [[x,y,z]....]
##and 2. the total Grid input with the format of [[xmin,ymin,zmin,xmax,ymax,zmax]
##.....[xmin,ymin,zmin,xmax,ymax,zmax]]. Thr output of the function is the the
##distribution of each coordidates according to the grid file. The format of the out
##out looks like[[[x1,y1,z1],[x2,y2,z2]]...].

def countWaterDistGrid(self):
    waterCoDist=[]
    for eachDis in self:
##        print len(eachDis)
        waterCoDist.append(len(eachDis))
    return waterCoDist

##countWaterNoDistGrid count the waters in each grid. It read the output of getWaterDisGrid.
##the output looks like[No.watersInGrid1,No.WatersInGrid2,....]

def getHighDensityGrid(self,value):
    highGrid=[]
    for No in range(len(self)):
        if self[No]>=value:
##            print No
            highGrid.append(No)
    return highGrid

##getHighDensityGrid read the water count distribution file with format of [No.watersInGrid1,No.
##WatersInGrid2,....] and determine which grid is filled with more waters in the grid. The value
##can be used as the threshold for the determination. the output is a serie of Number represent
##the grid in totalGrid.

def extractHighDensity(self,grids):
    highDensity=[]
    for number in self:
        highDensity.append(grids[number])
    return highDensity

##extracHighDensity read the output from getHighDensityGrid which inludes a series of grid numbers.
##The according elment in 'grids' with this number will be extraced to 'HighDensity'. This can be
##used to extract the high density grid from total grid, and extrat according waterCoDist in the grid.
##the output is extracted grid and waterCoDist.

def getCentre(self):
    centreAll=[]
    for coordSet in self:
        coordNo=0
        xsum=0
        ysum=0
        zsum=0
        for coord in coordSet:
            coordNo+=1
            xsum=xsum+coord[0]
            ysum=ysum+coord[1]
            zsum=zsum+coord[2]
        centre=[]
        centre.append(xsum/coordNo)
        centre.append(ysum/coordNo)
        centre.append(zsum/coordNo)
        centreAll.append(centre)
    return centreAll

##getCentre use a set of coordidate sets to find the centre of these sets. The input can be [[[x,y,z],[x,y,z]..]...]
##the output of this function is centre for each coordidate set [[xcen,ycen,zcen]...]

def determineMerge(self,threShould):
    centre2=[]
    for i in self:
        centre2.append(i)
    merge=[]
    
    deleted=[]
    for i in range(len(self)):
        eachMerge=[]
        eachMerge.append(i)
        a=numpy.array(self[i])
        
        if i not in deleted:
            deleted.append(i)
            for j in range(len(centre2)):
                if j not in deleted:
                    b=numpy.array(centre2[j])
                    dist = numpy.linalg.norm(a-b)
                    if dist <=threShould:
                        print self[i],'and',self[j],'has smaller distance, and merge it!!',dist
                        eachMerge.append(j)
                        deleted.append(j)
        if len(eachMerge)>=2:
            merge.append(eachMerge)
                                 
    return merge

##determingMerge is used to calculate the distance of each high densiy centre to determine which centre should be merged
##together. The input is the highly water occupied centre. the output is the pairs which should be merged.
  

def recaulcateCentre(self,highWaterCoor,originalCentre):
    deleted=[]
    newCentre=[]
    for merge in self:
        mergeCoor=[]
        
        
        for i in merge:
            mergeCoor=mergeCoor+highWaterCoor[i]
            deleted.append(i)
        xsum=0
        ysum=0
        zsum=0
        coordNo=0
            
        for coord in mergeCoor:
            coordNo+=1
            xsum=xsum+coord[0]
            ysum=ysum+coord[1]
            zsum=zsum+coord[2]
        centre=[]
        centre.append(xsum/coordNo)
        centre.append(ysum/coordNo)
        centre.append(zsum/coordNo)
        newCentre.append(centre)
    for i in range(len(originalCentre)):
        if i not in deleted:
            newCentre.append(originalCentre[i])
    
    return newCentre
  
def writeCentre(self,outPutFileName):
    for i in self:
        outPutFileName.write(str(i[0])+'    '+str(i[1])+'    '+str(i[2])+'\n')
    outPutFileName.close()

##This function read a set of coorditates and write it to file. The input is:[[x1,y1,z2]
##,[x2,y2,z2]...],outPutFileName is the output file name.

    
           
waterInfor=formatWaterInfor(waters)
print "the length of waterInfo: %s" %(len(waterInfor))
waterCoords=getWaterCoord(waterInfor,0,1)
print "the length of waterCoords: %s" %(len(waterCoords))
minAndMax=getMinAndMax(waterCoords)
print "the min and max is %s" %(minAndMax)
gridSize=divideGrid(minAndMax)
print "the grid size: %s" %(gridSize)
totalGrid=generateGrid(gridSize,minAndMax)
print "the total grid: %s" %(len(totalGrid))
#waterGridDist=getWaterDistGrid(waterCoords,totalGrid)
#print "the waterGridDist:%s" %(len(waterGridDist))
#
#
###number=0
###for i in waterGridDist:
###    if len(i)>15:
###        print len(i)
###    number=number+len(i)
###print 'there were', number,'were clustered'
#    
###print waterGridDist
waterCountDist=countWaterDistGrid(waterGridDist)
highDensity=getHighDensityGrid(waterCountDist,25)
print "highDensity:%s" %(len(highDensity))
highDensityGrid=extractHighDensity(highDensity,totalGrid)
#print "hihgDensityGrid:%s" %(highDensityGrid)
highDensityWaterGridDist=extractHighDensity(highDensity,waterGridDist)
#print "highDensityWaterGridDist:%s" %(len(highDensityWaterGridDist))
#
highDensityCentre=getCentre(highDensityWaterGridDist)
#
#print "highDensityCentre:%s" %(highDensityCentre)
#
shortDistance=determineMerge(highDensityCentre,2.4)
#print "schortDistance:%s" %(shortDistance)
#
newCentre=recaulcateCentre(shortDistance,highDensityWaterGridDist,highDensityCentre)
#
#print "len of newCentre:%" %(len(newCentre))
#print "newCentre:%s" %(newCentre)
#
writeCentre(newCentre,waterCentre)
#
#
#
